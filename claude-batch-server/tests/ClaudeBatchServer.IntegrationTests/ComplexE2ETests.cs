using System.Net;
using System.Net.Http.Json;
using FluentAssertions;
using Microsoft.AspNetCore.Mvc.Testing;
using Microsoft.Extensions.Configuration;
using ClaudeBatchServer.Api;
using ClaudeBatchServer.Core.DTOs;
using DotNetEnv;
using System.Diagnostics;

namespace ClaudeBatchServer.IntegrationTests;

public class ComplexE2ETests : IClassFixture<WebApplicationFactory<Program>>, IDisposable
{
    private readonly WebApplicationFactory<Program> _factory;
    private readonly HttpClient _client;
    private readonly string _testRepoPath;
    private readonly string _testJobsPath;
    private readonly string _targetProjectPath;

    public ComplexE2ETests(WebApplicationFactory<Program> factory)
    {
        // Load environment variables from .env file
        var envPath = "/home/jsbattig/Dev/claude-server/claude-batch-server/.env";
        if (File.Exists(envPath))
        {
            Env.Load(envPath);
        }
        
        _testRepoPath = Path.Combine(Path.GetTempPath(), "complex-e2e-repos", Guid.NewGuid().ToString());
        _testJobsPath = Path.Combine(Path.GetTempPath(), "complex-e2e-jobs", Guid.NewGuid().ToString());
        _targetProjectPath = Path.Combine(_testRepoPath, "fibonacci-project");
        
        _factory = factory.WithWebHostBuilder(builder =>
        {
            builder.ConfigureAppConfiguration((context, config) =>
            {
                config.AddInMemoryCollection(new Dictionary<string, string?>
                {
                    ["Jwt:Key"] = "ComplexE2ETestKeyForComplexEndToEndTestsThatIsLongEnough",
                    ["Jwt:ExpiryHours"] = "1",
                    ["Workspace:RepositoriesPath"] = _testRepoPath,
                    ["Workspace:JobsPath"] = _testJobsPath,
                    ["Jobs:MaxConcurrent"] = "1",
                    ["Jobs:TimeoutHours"] = "1",
                    ["Auth:ShadowFilePath"] = "/home/jsbattig/Dev/claude-server/claude-batch-server/test-shadow",
                    ["Claude:Command"] = "claude --dangerously-skip-permissions --print"
                });
            });
        });
        
        _client = _factory.CreateClient();
        
        SetupTestEnvironment();
    }

    private void SetupTestEnvironment()
    {
        Directory.CreateDirectory(_testRepoPath);
        Directory.CreateDirectory(_testJobsPath);
        
        // Create the target project directory (empty repository for Claude to work in)
        Directory.CreateDirectory(_targetProjectPath);
        
        // Create a basic README to establish it as a repository
        File.WriteAllText(Path.Combine(_targetProjectPath, "README.md"), "# Fibonacci Project\n\nGenerated by Claude Code via API");
        
        // Create .claude directory for Claude settings
        var claudeDir = Path.Combine(_targetProjectPath, ".claude");
        Directory.CreateDirectory(claudeDir);
        File.WriteAllText(Path.Combine(claudeDir, "settings.json"), "{}");
    }

    [Fact]
    public async Task ComplexWorkflow_GenerateFibonacciApplication_ShouldCreateWorkingProgram()
    {
        // Load environment variables for authentication
        var envPath = "/home/jsbattig/Dev/claude-server/claude-batch-server/.env";
        if (File.Exists(envPath))
        {
            Env.Load(envPath);
        }
        
        var username = Environment.GetEnvironmentVariable("TEST_USERNAME");
        var password = Environment.GetEnvironmentVariable("TEST_PASSWORD");
        
        if (string.IsNullOrEmpty(username) || string.IsNullOrEmpty(password))
        {
            throw new InvalidOperationException("TEST_USERNAME and TEST_PASSWORD environment variables must be set in .env file.");
        }

        // Step 1: Authenticate
        var loginRequest = new LoginRequest
        {
            Username = username,
            Password = password
        };

        var loginResponse = await _client.PostAsJsonAsync("/auth/login", loginRequest);
        loginResponse.StatusCode.Should().Be(HttpStatusCode.OK, "Authentication should succeed");
        
        var loginResult = await loginResponse.Content.ReadFromJsonAsync<LoginResponse>();
        loginResult.Should().NotBeNull();
        loginResult!.Token.Should().NotBeNullOrEmpty();

        var authClient = CreateAuthenticatedClient(loginResult.Token);

        // Step 2: Create complex job to generate Fibonacci application
        var fibonacciPrompt = @"Create a C# console application that calculates Fibonacci numbers. 

Make it accept a command line argument for how many numbers to generate, and print them out. Make it work with 'dotnet run -- 10' to show the first 10 Fibonacci numbers.

Create whatever files you think are needed to make this work.";

        var createJobRequest = new CreateJobRequest
        {
            Prompt = fibonacciPrompt,
            Repository = "fibonacci-project", // This maps to our target directory
            Options = new JobOptionsDto { Timeout = 120 } // Allow more time for complex generation
        };

        var createResponse = await authClient.PostAsJsonAsync("/jobs", createJobRequest);
        createResponse.StatusCode.Should().Be(HttpStatusCode.Created, "Job creation should succeed");
        
        var jobResponse = await createResponse.Content.ReadFromJsonAsync<CreateJobResponse>();
        jobResponse.Should().NotBeNull();
        jobResponse!.JobId.Should().NotBeEmpty();

        Console.WriteLine($"Created job {jobResponse.JobId} for Fibonacci application generation");

        // Step 3: Start the job
        var startResponse = await authClient.PostAsync($"/jobs/{jobResponse.JobId}/start", null);
        startResponse.StatusCode.Should().Be(HttpStatusCode.OK, "Job start should succeed");

        Console.WriteLine("Job started, waiting 0.5 seconds before polling...");

        // Step 4: Wait 0.5 seconds as requested
        await Task.Delay(500);

        // Step 5: Poll for completion with detailed progress tracking
        JobStatusResponse? statusResponse = null;
        var timeout = DateTime.UtcNow.AddMinutes(5); // Give Claude time to generate the code
        var pollCount = 0;
        const int maxPolls = 100; // Max 100 polls (5 minutes with 3-second intervals)
        var statusesObserved = new List<string>();

        Console.WriteLine("Starting to poll job status...");

        while (DateTime.UtcNow < timeout && pollCount < maxPolls)
        {
            await Task.Delay(3000); // Wait 3 seconds between polls
            pollCount++;
            
            var statusHttpResponse = await authClient.GetAsync($"/jobs/{jobResponse.JobId}");
            statusHttpResponse.StatusCode.Should().Be(HttpStatusCode.OK, $"Job status check should succeed on poll {pollCount}");
            
            statusResponse = await statusHttpResponse.Content.ReadFromJsonAsync<JobStatusResponse>();
            statusResponse.Should().NotBeNull($"Job status response should not be null on poll {pollCount}");
            
            statusesObserved.Add(statusResponse!.Status);
            Console.WriteLine($"Poll {pollCount}: Job status = {statusResponse.Status}");
            
            if (statusResponse.Status == "completed" || statusResponse.Status == "failed")
            {
                Console.WriteLine($"Job finished with status: {statusResponse.Status}");
                break;
            }
        }

        // Step 6: Verify we observed a "running" status (Claude takes time to execute)
        statusesObserved.Should().Contain("running", 
            "Should observe 'running' status since Claude Code takes longer than 0.5 seconds to execute");
        Console.WriteLine($"‚úÖ Observed statuses: {string.Join(" ‚Üí ", statusesObserved.Distinct())}");

        // Step 7: Verify job completion
        statusResponse.Should().NotBeNull("Final status response should not be null");
        
        if (statusResponse!.Status == "failed")
        {
            Console.WriteLine($"Job failed with exit code: {statusResponse.ExitCode}");
            Console.WriteLine($"Job output: {statusResponse.Output}");
        }
        
        statusResponse.Status.Should().Be("completed", "Job should complete successfully");
        statusResponse.ExitCode.Should().Be(0, "Claude Code should exit successfully");
        statusResponse.Output.Should().NotBeNullOrEmpty("Claude should produce output");

        Console.WriteLine("Job completed successfully!");
        Console.WriteLine($"Claude output: {statusResponse.Output}");

        // Step 8: Debug - Check what files are in the directory
        Console.WriteLine($"COW Path: {statusResponse.CowPath}");
        if (Directory.Exists(statusResponse.CowPath))
        {
            var files = Directory.GetFiles(statusResponse.CowPath, "*", SearchOption.AllDirectories);
            Console.WriteLine($"Files in COW directory ({files.Length}):");
            foreach (var file in files)
            {
                Console.WriteLine($"  - {file}");
            }
        }
        else
        {
            Console.WriteLine($"COW directory does not exist: {statusResponse.CowPath}");
        }

        // Step 9: Verify Claude created files (let Claude decide what to create)
        var csFiles = Directory.GetFiles(statusResponse.CowPath, "*.cs", SearchOption.AllDirectories);
        var projFiles = Directory.GetFiles(statusResponse.CowPath, "*.csproj", SearchOption.AllDirectories);
        
        Console.WriteLine($"‚úÖ Claude created {csFiles.Length} .cs files and {projFiles.Length} .csproj files");
        
        // We expect at least some C# files to be created
        csFiles.Length.Should().BeGreaterThan(0, "Claude should create at least one C# file");

        // If Claude didn't create a project file, create a simple one
        if (projFiles.Length == 0)
        {
            Console.WriteLine("üìù Creating basic project file since Claude didn't create one");
            var projectContent = @"<Project Sdk=""Microsoft.NET.Sdk"">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>net8.0</TargetFramework>
  </PropertyGroup>
</Project>";

            var projectFilePath = Path.Combine(statusResponse.CowPath, "FibonacciApp.csproj");
            await File.WriteAllTextAsync(projectFilePath, projectContent);
        }

        Console.WriteLine("‚úÖ Project ready for compilation");

        // Step 10: Compile and run the generated program with N=10
        var compileResult = await RunProcessAsync("dotnet", "build", statusResponse.CowPath);
        compileResult.ExitCode.Should().Be(0, $"Code should compile successfully. Output: {compileResult.Output}");

        Console.WriteLine("‚úÖ Code compiled successfully");

        // Step 11: Run the program with N=10 and verify Fibonacci sequence
        var runResult = await RunProcessAsync("dotnet", "run --project . -- 10", statusResponse.CowPath);
        runResult.ExitCode.Should().Be(0, $"Program should run successfully. Output: {runResult.Output}");

        Console.WriteLine($"‚úÖ Program executed successfully");
        Console.WriteLine($"Program output:\n{runResult.Output}");

        // Step 12: Verify the output looks like Fibonacci numbers (simplified)
        var outputLines = runResult.Output.Split('\n', StringSplitOptions.RemoveEmptyEntries)
                                          .Select(line => line.Trim())
                                          .Where(line => !string.IsNullOrEmpty(line) && char.IsDigit(line[0]))
                                          .ToArray();

        Console.WriteLine($"Program output lines with numbers: {outputLines.Length}");
        foreach (var line in outputLines.Take(10))
        {
            Console.WriteLine($"  {line}");
        }

        // Just verify we got some numeric output (let Claude implement however it wants)
        outputLines.Length.Should().BeGreaterThan(5, "Should produce at least several numbers");
        
        // Verify some common Fibonacci numbers appear in the output
        var outputText = string.Join(" ", outputLines);
        outputText.Should().Contain("0", "Should contain 0 (first Fibonacci number)");
        outputText.Should().Contain("1", "Should contain 1 (second Fibonacci number)");

        Console.WriteLine($"üéâ Complex E2E test completed successfully!");
        Console.WriteLine($"‚úÖ Generated working C# application with {csFiles.Length} files");
        Console.WriteLine($"‚úÖ Application compiled and ran successfully");
        Console.WriteLine($"‚úÖ Produced {outputLines.Length} lines of numeric output");
        Console.WriteLine($"‚úÖ Full development workflow: API ‚Üí Code Generation ‚Üí Compilation ‚Üí Execution ‚Üí Verification");
    }

    private HttpClient CreateAuthenticatedClient(string token)
    {
        var client = _factory.CreateClient();
        client.DefaultRequestHeaders.Authorization = 
            new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", token);
        return client;
    }

    private async Task<(int ExitCode, string Output)> RunProcessAsync(string command, string arguments, string workingDirectory)
    {
        var processInfo = new ProcessStartInfo
        {
            FileName = command,
            Arguments = arguments,
            WorkingDirectory = workingDirectory,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true
        };

        using var process = new Process { StartInfo = processInfo };
        
        var outputBuilder = new System.Text.StringBuilder();
        var errorBuilder = new System.Text.StringBuilder();

        process.OutputDataReceived += (sender, e) =>
        {
            if (!string.IsNullOrEmpty(e.Data))
            {
                outputBuilder.AppendLine(e.Data);
            }
        };

        process.ErrorDataReceived += (sender, e) =>
        {
            if (!string.IsNullOrEmpty(e.Data))
            {
                errorBuilder.AppendLine(e.Data);
            }
        };

        process.Start();
        process.BeginOutputReadLine();
        process.BeginErrorReadLine();

        await process.WaitForExitAsync();

        var output = outputBuilder.ToString();
        var error = errorBuilder.ToString();

        if (!string.IsNullOrEmpty(error))
        {
            output += "\nErrors:\n" + error;
        }

        return (process.ExitCode, output);
    }

    public void Dispose()
    {
        try
        {
            if (Directory.Exists(_testRepoPath))
                Directory.Delete(_testRepoPath, true);
            if (Directory.Exists(_testJobsPath))
                Directory.Delete(_testJobsPath, true);
        }
        catch
        {
            // Ignore cleanup errors
        }
        
        _client?.Dispose();
    }
}