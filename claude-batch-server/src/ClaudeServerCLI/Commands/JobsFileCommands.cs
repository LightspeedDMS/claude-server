using System.CommandLine;
using System.CommandLine.Invocation;
using System.Text.Json;
using Spectre.Console;
using ClaudeServerCLI.Services;
using ClaudeServerCLI.Models;
using YamlDotNet.Serialization;

namespace ClaudeServerCLI.Commands;

public class JobFilesCommand : Command
{
    public JobFilesCommand() : base("files", """
        Job file management commands
        
        Manage files within job workspaces. Upload files for job input,
        download job results, and browse job file contents.
        
        EXAMPLES:
          # List files in job workspace
          claude-server jobs files list abc123
          
          # Upload file to job
          claude-server jobs files upload abc123 ./input.txt
          
          # Download job output file
          claude-server jobs files download abc123 output.txt --output ./result.txt
          
          # Delete job file
          claude-server jobs files delete abc123 temp-file.txt
          
          # Export file listings as JSON/YAML
          claude-server jobs files list abc123 --format json
        """)
    {
        AddCommand(new JobFilesListCommand());
        AddCommand(new JobFilesUploadCommand());
        AddCommand(new JobFilesDownloadCommand());
        AddCommand(new JobFilesDeleteCommand());
    }
}

public class JobFilesListCommand : AuthenticatedCommand
{
    private readonly Argument<string> _jobIdArgument;
    private readonly Option<string> _formatOption;
    private readonly Option<bool> _quietOption;

    public JobFilesListCommand() : base("list", """
        List files in a job workspace
        
        Browse files uploaded to or generated by a job. Shows file names,
        sizes, and creation timestamps.
        
        EXAMPLES:
          # List all files in job
          claude-server jobs files list abc123
          
          # Export as JSON for scripting
          claude-server jobs files list abc123 --format json
          
          # Export as YAML for configuration
          claude-server jobs files list abc123 --format yaml
        """)
    {
        _jobIdArgument = new Argument<string>(
            name: "jobId",
            description: "Job ID (full or partial)"
        );

        _formatOption = new Option<string>(
            aliases: ["--format", "-f"],
            description: "Output format: 'table', 'json', 'yaml'",
            getDefaultValue: () => "table"
        );

        _quietOption = new Option<bool>(
            aliases: ["--quiet", "-q"],
            description: "Suppress progress messages and ANSI output (for testing/automation)",
            getDefaultValue: () => false
        );

        AddArgument(_jobIdArgument);
        AddOption(_formatOption);
        AddOption(_quietOption);
    }

    protected override async Task<int> ExecuteAuthenticatedAsync(InvocationContext context, string profile, IApiClient apiClient)
    {
        var jobId = context.ParseResult.GetValueForArgument(_jobIdArgument);
        var format = context.ParseResult.GetValueForOption(_formatOption) ?? "table";
        var quiet = context.ParseResult.GetValueForOption(_quietOption);
        var cancellationToken = context.GetCancellationToken();

        // Resolve partial job ID if needed
        var fullJobId = await ResolveJobIdAsync(apiClient, jobId, cancellationToken);
        if (string.IsNullOrEmpty(fullJobId))
        {
            WriteError($"Job '{jobId}' not found");
            return 1;
        }

        try
        {
            if (!quiet)
            {
                WriteInfo($"Listing files in job '{fullJobId[..8]}'...");
            }
            
            var files = await apiClient.GetJobFilesAsync(fullJobId, cancellationToken);
            
            DisplayJobFiles(files, format);
            return 0;
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("not found"))
        {
            WriteError($"Job '{jobId}' not found");
            return 1;
        }
        catch (Exception ex)
        {
            WriteError($"Failed to list job files: {ex.Message}");
            return 1;
        }
    }

    private async Task<string?> ResolveJobIdAsync(IApiClient apiClient, string partialId, CancellationToken cancellationToken)
    {
        try
        {
            // Try as full GUID first
            if (Guid.TryParse(partialId, out _))
            {
                try
                {
                    await apiClient.GetJobAsync(partialId, cancellationToken);
                    return partialId;
                }
                catch (Exception ex)
                {
                    WriteError($"Failed to verify job '{partialId}': {ex.Message}");
                    return null;
                }
            }

            // Search for partial match
            try
            {
                var jobs = await apiClient.GetJobsAsync(new CliJobFilter { Limit = 100 }, cancellationToken);
                var matches = jobs.Where(j => j.JobId.ToString().StartsWith(partialId, StringComparison.OrdinalIgnoreCase)).ToList();

                if (matches.Count == 0)
                {
                    WriteError($"No jobs found matching '{partialId}'");
                    return null;
                }

                if (matches.Count > 1)
                {
                    WriteWarning($"Multiple jobs found matching '{partialId}':");
                    foreach (var match in matches.Take(5))
                    {
                        WriteInfo($"  {match.JobId} - {match.Repository} ({match.Status})");
                    }
                    WriteError("Please provide a more specific job ID");
                    return null;
                }

                return matches[0].JobId.ToString();
            }
            catch (Exception ex)
            {
                WriteError($"Failed to search for jobs matching '{partialId}': {ex.Message}");
                return null;
            }
        }
        catch (Exception ex)
        {
            WriteError($"Unexpected error in job resolution: {ex.Message}");
            return null;
        }
    }

    private static void DisplayJobFiles(IEnumerable<JobFile> files, string format)
    {
        switch (format.ToLowerInvariant())
        {
            case "json":
                var json = JsonSerializer.Serialize(files, new JsonSerializerOptions { WriteIndented = true });
                Console.WriteLine(json);
                break;
                
            case "yaml":
                var serializer = new SerializerBuilder().Build();
                var yaml = serializer.Serialize(files);
                Console.WriteLine(yaml);
                break;
                
            case "table":
            default:
                if (!files.Any())
                {
                    AnsiConsole.MarkupLine("[grey]No files found[/]");
                    return;
                }

                var table = new Table();
                table.AddColumn("Name");
                table.AddColumn("Size");
                table.AddColumn("Created");

                foreach (var file in files.OrderBy(f => !string.IsNullOrEmpty(f.FileName) ? f.FileName : f.Name))
                {
                    var size = FormatFileSize(file.Size);
                    var created = file.CreatedAt.ToString("yyyy-MM-dd HH:mm:ss");
                    
                    // Use FileName if not empty, otherwise use Name
                    var displayName = !string.IsNullOrEmpty(file.FileName) ? file.FileName : file.Name;
                    table.AddRow(displayName, size, created);
                }

                AnsiConsole.Write(table);
                break;
        }
    }

    private static string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024:F1} KB";
        if (bytes < 1024 * 1024 * 1024) return $"{bytes / (1024 * 1024):F1} MB";
        return $"{bytes / (1024 * 1024 * 1024):F1} GB";
    }
}

public class JobFilesUploadCommand : AuthenticatedCommand
{
    private readonly Argument<string> _jobIdArgument;
    private readonly Argument<string> _localFileArgument;
    private readonly Option<string> _nameOption;
    private readonly Option<bool> _overwriteOption;
    private readonly Option<bool> _quietOption;

    public JobFilesUploadCommand() : base("upload", """
        Upload a file to a job workspace
        
        Upload local files to job workspaces for use as input or configuration.
        Files are accessible to the job during execution.
        
        EXAMPLES:
          # Upload file with original name
          claude-server jobs files upload abc123 ./input.txt
          
          # Upload with custom name
          claude-server jobs files upload abc123 ./data.csv --name job-data.csv
          
          # Overwrite existing file
          claude-server jobs files upload abc123 ./config.json --overwrite
        """)
    {
        _jobIdArgument = new Argument<string>(
            name: "jobId",  
            description: "Job ID (full or partial)"
        );

        _localFileArgument = new Argument<string>(
            name: "localFile",
            description: "Path to local file to upload"
        );

        _nameOption = new Option<string>(
            aliases: ["--name", "-n"],
            description: "Custom filename in job workspace (default: use local filename)"
        );

        _overwriteOption = new Option<bool>(
            aliases: ["--overwrite"],
            description: "Overwrite existing file if it exists",
            getDefaultValue: () => false
        );

        _quietOption = new Option<bool>(
            aliases: ["--quiet", "-q"],
            description: "Suppress progress messages and ANSI output (for testing/automation)",
            getDefaultValue: () => false
        );

        AddArgument(_jobIdArgument);
        AddArgument(_localFileArgument);
        AddOption(_nameOption);
        AddOption(_overwriteOption);
        AddOption(_quietOption);
    }

    protected override async Task<int> ExecuteAuthenticatedAsync(InvocationContext context, string profile, IApiClient apiClient)
    {
        var jobId = context.ParseResult.GetValueForArgument(_jobIdArgument);
        var localFilePath = context.ParseResult.GetValueForArgument(_localFileArgument);
        var customName = context.ParseResult.GetValueForOption(_nameOption);
        var overwrite = context.ParseResult.GetValueForOption(_overwriteOption);
        var quiet = context.ParseResult.GetValueForOption(_quietOption);
        var cancellationToken = context.GetCancellationToken();

        // Check if local file exists
        if (!File.Exists(localFilePath))
        {
            WriteError($"Local file '{localFilePath}' not found");
            return 1;
        }

        // Resolve partial job ID if needed
        var fullJobId = await ResolveJobIdAsync(apiClient, jobId, cancellationToken);
        if (string.IsNullOrEmpty(fullJobId))
        {
            WriteError($"Job '{jobId}' not found");
            return 1;
        }

        try
        {
            if (!quiet)
            {
                WriteInfo($"Uploading '{localFilePath}' to job '{fullJobId[..8]}'...");
            }
            
            var fileContent = await File.ReadAllBytesAsync(localFilePath, cancellationToken);
            var fileName = customName ?? Path.GetFileName(localFilePath);
            
            var fileUpload = new FileUpload
            {
                FileName = fileName,
                Content = fileContent
            };

            var response = await apiClient.UploadSingleFileAsync(fullJobId, fileUpload, overwrite, cancellationToken);
            
            if (!quiet)
            {
                WriteSuccess($"Uploaded '{fileName}' ({FormatFileSize(response.FileSize)})");
                if (response.Overwritten)
                {
                    WriteInfo("File was overwritten");
                }
            }
            return 0;
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("not found"))
        {
            WriteError($"Job '{jobId}' not found");
            return 1;
        }
        catch (Exception ex)
        {
            WriteError($"Failed to upload file: {ex.Message}");
            return 1;
        }
    }

    private async Task<string?> ResolveJobIdAsync(IApiClient apiClient, string partialId, CancellationToken cancellationToken)
    {
        try
        {
            // Try as full GUID first
            if (Guid.TryParse(partialId, out _))
            {
                try
                {
                    await apiClient.GetJobAsync(partialId, cancellationToken);
                    return partialId;
                }
                catch (Exception ex)
                {
                    WriteError($"Failed to verify job '{partialId}': {ex.Message}");
                    return null;
                }
            }

            // Search for partial match
            try
            {
                var jobs = await apiClient.GetJobsAsync(new CliJobFilter { Limit = 100 }, cancellationToken);
                var matches = jobs.Where(j => j.JobId.ToString().StartsWith(partialId, StringComparison.OrdinalIgnoreCase)).ToList();

                if (matches.Count == 0)
                {
                    WriteError($"No jobs found matching '{partialId}'");
                    return null;
                }

                if (matches.Count > 1)
                {
                    WriteError($"Multiple jobs found matching '{partialId}' - please be more specific");
                    return null;
                }

                return matches[0].JobId.ToString();
            }
            catch (Exception ex)
            {
                WriteError($"Failed to search for jobs matching '{partialId}': {ex.Message}");
                return null;
            }
        }
        catch (Exception ex)
        {
            WriteError($"Unexpected error in job resolution: {ex.Message}");
            return null;
        }
    }

    private static string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024:F1} KB";
        if (bytes < 1024 * 1024 * 1024) return $"{bytes / (1024 * 1024):F1} MB";
        return $"{bytes / (1024 * 1024 * 1024):F1} GB";
    }
}

public class JobFilesDownloadCommand : AuthenticatedCommand
{
    private readonly Argument<string> _jobIdArgument;
    private readonly Argument<string> _fileNameArgument;
    private readonly Option<string> _outputOption;
    private readonly Option<bool> _overwriteOption;

    public JobFilesDownloadCommand() : base("download", """
        Download a file from a job workspace
        
        Download files from job workspaces to your local machine.
        Can download input files, output files, or intermediate results.
        
        EXAMPLES:
          # Download to current directory with original name
          claude-server jobs files download abc123 output.txt
          
          # Download with custom output path
          claude-server jobs files download abc123 results.json --output ./job-results.json
          
          # Overwrite existing local file
          claude-server jobs files download abc123 log.txt --output ./job.log --overwrite
        """)
    {
        _jobIdArgument = new Argument<string>(
            name: "jobId",
            description: "Job ID (full or partial)"
        );

        _fileNameArgument = new Argument<string>(
            name: "fileName",
            description: "Name of file in job workspace"
        );

        _outputOption = new Option<string>(
            aliases: ["--output", "-o"],
            description: "Output file path (default: use original filename in current directory)"
        );

        _overwriteOption = new Option<bool>(
            aliases: ["--overwrite"],
            description: "Overwrite existing local file if it exists",
            getDefaultValue: () => false
        );

        AddArgument(_jobIdArgument);
        AddArgument(_fileNameArgument);
        AddOption(_outputOption);
        AddOption(_overwriteOption);
    }

    protected override async Task<int> ExecuteAuthenticatedAsync(InvocationContext context, string profile, IApiClient apiClient)
    {
        var jobId = context.ParseResult.GetValueForArgument(_jobIdArgument);
        var fileName = context.ParseResult.GetValueForArgument(_fileNameArgument);
        var outputPath = context.ParseResult.GetValueForOption(_outputOption);
        var overwrite = context.ParseResult.GetValueForOption(_overwriteOption);
        var cancellationToken = context.GetCancellationToken();

        // Determine output path
        if (string.IsNullOrEmpty(outputPath))
        {
            outputPath = fileName;
        }

        // Check if output file already exists
        if (File.Exists(outputPath) && !overwrite)
        {
            WriteError($"Output file '{outputPath}' already exists");
            WriteInfo("Use --overwrite to replace the existing file");
            return 1;
        }

        // Resolve partial job ID if needed
        var fullJobId = await ResolveJobIdAsync(apiClient, jobId, cancellationToken);
        if (string.IsNullOrEmpty(fullJobId))
        {
            WriteError($"Job '{jobId}' not found");
            return 1;
        }

        try
        {
            WriteInfo($"Downloading '{fileName}' from job '{fullJobId[..8]}'...");
            
            var fileStream = await apiClient.DownloadJobFileAsync(fullJobId, fileName, cancellationToken);
            
            using (var outputStream = File.Create(outputPath))
            {
                await fileStream.CopyToAsync(outputStream, cancellationToken);
            }
            
            var fileInfo = new System.IO.FileInfo(outputPath);
            WriteSuccess($"Downloaded '{fileName}' to '{outputPath}' ({FormatFileSize(fileInfo.Length)})");
            return 0;
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("not found"))
        {
            if (ex.Message.Contains("Job"))
            {
                WriteError($"Job '{jobId}' not found");
            }
            else
            {
                WriteError($"File '{fileName}' not found in job '{jobId}'");
            }
            return 1;
        }
        catch (UnauthorizedAccessException)
        {
            WriteError($"Permission denied writing to '{outputPath}'");
            return 1;
        }
        catch (Exception ex)
        {
            WriteError($"Failed to download file: {ex.Message}");
            return 1;
        }
    }

    private async Task<string?> ResolveJobIdAsync(IApiClient apiClient, string partialId, CancellationToken cancellationToken)
    {
        try
        {
            // Try as full GUID first
            if (Guid.TryParse(partialId, out _))
            {
                try
                {
                    await apiClient.GetJobAsync(partialId, cancellationToken);
                    return partialId;
                }
                catch (Exception ex)
                {
                    WriteError($"Failed to verify job '{partialId}': {ex.Message}");
                    return null;
                }
            }

            // Search for partial match
            try
            {
                var jobs = await apiClient.GetJobsAsync(new CliJobFilter { Limit = 100 }, cancellationToken);
                var matches = jobs.Where(j => j.JobId.ToString().StartsWith(partialId, StringComparison.OrdinalIgnoreCase)).ToList();

                if (matches.Count == 0)
                {
                    WriteError($"No jobs found matching '{partialId}'");
                    return null;
                }

                if (matches.Count > 1)
                {
                    WriteError($"Multiple jobs found matching '{partialId}' - please be more specific");
                    return null;
                }

                return matches[0].JobId.ToString();
            }
            catch (Exception ex)
            {
                WriteError($"Failed to search for jobs matching '{partialId}': {ex.Message}");
                return null;
            }
        }
        catch (Exception ex)
        {
            WriteError($"Unexpected error in job resolution: {ex.Message}");
            return null;
        }
    }

    private static string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024:F1} KB";
        if (bytes < 1024 * 1024 * 1024) return $"{bytes / (1024 * 1024):F1} MB";
        return $"{bytes / (1024 * 1024 * 1024):F1} GB";
    }
}

public class JobFilesDeleteCommand : AuthenticatedCommand
{
    private readonly Argument<string> _jobIdArgument;
    private readonly Argument<string> _fileNameArgument;
    private readonly Option<bool> _forceOption;

    public JobFilesDeleteCommand() : base("delete", """
        Delete a file from a job workspace
        
        Remove files from job workspaces to free up space or clean up
        temporary files. Use with caution as this operation cannot be undone.
        
        EXAMPLES:
          # Delete file with confirmation
          claude-server jobs files delete abc123 temp-file.txt
          
          # Delete file without confirmation
          claude-server jobs files delete abc123 old-data.csv --force
        """)
    {
        _jobIdArgument = new Argument<string>(
            name: "jobId",
            description: "Job ID (full or partial)"
        );

        _fileNameArgument = new Argument<string>(
            name: "fileName",
            description: "Name of file to delete"
        );

        _forceOption = new Option<bool>(
            aliases: ["--force", "-f"],
            description: "Delete without confirmation",
            getDefaultValue: () => false
        );

        AddArgument(_jobIdArgument);
        AddArgument(_fileNameArgument);
        AddOption(_forceOption);
    }

    protected override async Task<int> ExecuteAuthenticatedAsync(InvocationContext context, string profile, IApiClient apiClient)
    {
        var jobId = context.ParseResult.GetValueForArgument(_jobIdArgument);
        var fileName = context.ParseResult.GetValueForArgument(_fileNameArgument);
        var force = context.ParseResult.GetValueForOption(_forceOption);
        var cancellationToken = context.GetCancellationToken();

        // Resolve partial job ID if needed
        var fullJobId = await ResolveJobIdAsync(apiClient, jobId, cancellationToken);
        if (string.IsNullOrEmpty(fullJobId))
        {
            WriteError($"Job '{jobId}' not found");
            return 1;
        }

        try
        {
            // Check if file exists first
            var files = await apiClient.GetJobFilesAsync(fullJobId, cancellationToken);
            var targetFile = files.FirstOrDefault(f => 
            {
                var fileDisplayName = !string.IsNullOrEmpty(f.FileName) ? f.FileName : f.Name;
                return fileDisplayName.Equals(fileName, StringComparison.OrdinalIgnoreCase);
            });
            
            if (targetFile == null)
            {
                WriteError($"File '{fileName}' not found in job '{jobId}'");
                return 1;
            }

            if (!force)
            {
                WriteWarning($"This will delete file '{fileName}' from job '{fullJobId[..8]}'");
                WriteWarning($"Size: {FormatFileSize(targetFile.Size)}");
                WriteWarning($"Created: {targetFile.CreatedAt:yyyy-MM-dd HH:mm:ss}");
                
                if (!AnsiConsole.Confirm("Are you sure you want to continue?"))
                {
                    WriteInfo("Operation cancelled");
                    return 0;
                }
            }

            WriteInfo($"Deleting '{fileName}' from job '{fullJobId[..8]}'...");
            
            await apiClient.DeleteJobFileAsync(fullJobId, fileName, cancellationToken);
            
            WriteSuccess($"Deleted '{fileName}' from job '{fullJobId[..8]}'");
            return 0;
        }
        catch (InvalidOperationException ex) when (ex.Message.Contains("not found"))
        {
            WriteError($"Job '{jobId}' not found");
            return 1;
        }
        catch (Exception ex)
        {
            WriteError($"Failed to delete file: {ex.Message}");
            return 1;
        }
    }

    private async Task<string?> ResolveJobIdAsync(IApiClient apiClient, string partialId, CancellationToken cancellationToken)
    {
        try
        {
            // Try as full GUID first
            if (Guid.TryParse(partialId, out _))
            {
                try
                {
                    await apiClient.GetJobAsync(partialId, cancellationToken);
                    return partialId;
                }
                catch (Exception ex)
                {
                    WriteError($"Failed to verify job '{partialId}': {ex.Message}");
                    return null;
                }
            }

            // Search for partial match
            try
            {
                var jobs = await apiClient.GetJobsAsync(new CliJobFilter { Limit = 100 }, cancellationToken);
                var matches = jobs.Where(j => j.JobId.ToString().StartsWith(partialId, StringComparison.OrdinalIgnoreCase)).ToList();

                if (matches.Count == 0)
                {
                    WriteError($"No jobs found matching '{partialId}'");
                    return null;
                }

                if (matches.Count > 1)
                {
                    WriteError($"Multiple jobs found matching '{partialId}' - please be more specific");
                    return null;
                }

                return matches[0].JobId.ToString();
            }
            catch (Exception ex)
            {
                WriteError($"Failed to search for jobs matching '{partialId}': {ex.Message}");
                return null;
            }
        }
        catch (Exception ex)
        {
            WriteError($"Unexpected error in job resolution: {ex.Message}");
            return null;
        }
    }

    private static string FormatFileSize(long bytes)
    {
        if (bytes < 1024) return $"{bytes} B";
        if (bytes < 1024 * 1024) return $"{bytes / 1024:F1} KB";
        if (bytes < 1024 * 1024 * 1024) return $"{bytes / (1024 * 1024):F1} MB";
        return $"{bytes / (1024 * 1024 * 1024):F1} GB";
    }
}